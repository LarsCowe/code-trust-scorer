/**
 * Code Analysis Engine
 * 
 * Analyzes code for AI-specific issues like hallucinated APIs,
 * deprecated methods, and security vulnerabilities.
 */

export type IssueType =
  | "hallucinated-api"
  | "deprecated-method"
  | "security-vulnerability"
  | "quality-issue"
  | "style-issue";

export type Severity = "error" | "warning" | "info";

export interface AnalysisIssue {
  type: IssueType;
  severity: Severity;
  ruleId: string;
  message: string;
  suggestion?: string;
  line: number;
  column: number;
  endLine?: number;
  endColumn?: number;
  codeSnippet?: string;
  confidence: number;
}

export interface AnalysisResult {
  trustScore: number;
  confidence: number;
  issues: AnalysisIssue[];
  linesOfCode: number;
  analysisTime: number;
  metadata: {
    language: string;
    framework?: string;
    errorCount: number;
    warningCount: number;
    infoCount: number;
  };
}

export interface AnalysisOptions {
  language: "typescript" | "javascript" | "python" | "tsx" | "jsx";
  fileName?: string;
  maxIssues?: number;
  enabledRules?: string[];
}

// Known hallucinated APIs (commonly generated by AI but don't exist)
const HALLUCINATED_APIS: Record<string, { correct: string; message: string }> = {
  "Array.prototype.flatten": {
    correct: "Array.prototype.flat",
    message: "Array.flatten() does not exist. Use Array.flat() instead.",
  },
  "Array.prototype.compact": {
    correct: "Array.prototype.filter(Boolean)",
    message: "Array.compact() does not exist. Use .filter(Boolean) instead.",
  },
  "String.prototype.contains": {
    correct: "String.prototype.includes",
    message: "String.contains() does not exist. Use String.includes() instead.",
  },
  "Object.deepMerge": {
    correct: "structuredClone + spread",
    message: "Object.deepMerge() does not exist. Consider using structuredClone() or a library.",
  },
  "Promise.sleep": {
    correct: "new Promise(r => setTimeout(r, ms))",
    message: "Promise.sleep() does not exist. Create a custom sleep function.",
  },
  "JSON.parseAsync": {
    correct: "JSON.parse",
    message: "JSON.parseAsync() does not exist. JSON.parse is synchronous.",
  },
  "Math.clamp": {
    correct: "Math.min(Math.max(value, min), max)",
    message: "Math.clamp() does not exist. Use Math.min/max combination.",
  },
  "Number.isNumeric": {
    correct: "Number.isFinite or !isNaN",
    message: "Number.isNumeric() does not exist. Use Number.isFinite() or !isNaN().",
  },
  "document.query": {
    correct: "document.querySelector",
    message: "document.query() does not exist. Use document.querySelector().",
  },
  "document.queryAll": {
    correct: "document.querySelectorAll",
    message: "document.queryAll() does not exist. Use document.querySelectorAll().",
  },
};

// Deprecated methods database
const DEPRECATED_METHODS: Record<string, { replacement: string; since: string }> = {
  "componentWillMount": {
    replacement: "useEffect hook or componentDidMount",
    since: "React 16.3",
  },
  "componentWillReceiveProps": {
    replacement: "getDerivedStateFromProps or useEffect",
    since: "React 16.3",
  },
  "componentWillUpdate": {
    replacement: "getSnapshotBeforeUpdate or useEffect",
    since: "React 16.3",
  },
  "url.parse": {
    replacement: "new URL() constructor",
    since: "Node.js 11.0.0",
  },
  "path.exists": {
    replacement: "fs.existsSync or fs.access",
    since: "Node.js 1.0.0",
  },
  "document.write": {
    replacement: "DOM manipulation methods",
    since: "HTML5",
  },
  "escape": {
    replacement: "encodeURIComponent",
    since: "ES5",
  },
  "unescape": {
    replacement: "decodeURIComponent",
    since: "ES5",
  },
  "__defineGetter__": {
    replacement: "Object.defineProperty",
    since: "ES5",
  },
  "__defineSetter__": {
    replacement: "Object.defineProperty",
    since: "ES5",
  },
};

// Security vulnerability patterns
const SECURITY_PATTERNS: Array<{
  pattern: RegExp;
  ruleId: string;
  severity: Severity;
  message: string;
  suggestion: string;
}> = [
  {
    pattern: /eval\s*\(/g,
    ruleId: "security/no-eval",
    severity: "error",
    message: "Use of eval() is a security vulnerability",
    suggestion: "Avoid eval(). Use JSON.parse() for JSON data or Function constructor if absolutely necessary.",
  },
  {
    pattern: /innerHTML\s*=/g,
    ruleId: "security/no-inner-html",
    severity: "warning",
    message: "Direct innerHTML assignment can lead to XSS vulnerabilities",
    suggestion: "Use textContent for text or sanitize HTML before assignment.",
  },
  {
    pattern: /new\s+Function\s*\(/g,
    ruleId: "security/no-new-function",
    severity: "error",
    message: "Use of new Function() is similar to eval() and poses security risks",
    suggestion: "Avoid dynamic function creation. Use regular function declarations.",
  },
  {
    pattern: /document\.write\s*\(/g,
    ruleId: "security/no-document-write",
    severity: "warning",
    message: "document.write() can be exploited for XSS attacks",
    suggestion: "Use DOM manipulation methods like appendChild() or insertAdjacentHTML().",
  },
  {
    pattern: /localStorage\.setItem\s*\(\s*['"`](?:password|token|secret|key|auth)/gi,
    ruleId: "security/no-sensitive-localStorage",
    severity: "error",
    message: "Storing sensitive data in localStorage is insecure",
    suggestion: "Use secure, httpOnly cookies for sensitive tokens. Consider encrypted storage.",
  },
  {
    pattern: /(?:password|secret|api[_-]?key|token)\s*[:=]\s*['"`][^'"`]+['"`]/gi,
    ruleId: "security/no-hardcoded-secrets",
    severity: "error",
    message: "Hardcoded credentials or secrets detected",
    suggestion: "Use environment variables for secrets. Never commit credentials to code.",
  },
  {
    pattern: /Math\.random\s*\(\)/g,
    ruleId: "security/weak-randomness",
    severity: "info",
    message: "Math.random() is not cryptographically secure",
    suggestion: "For security-sensitive operations, use crypto.getRandomValues() or crypto.randomUUID().",
  },
  {
    pattern: /exec\s*\(\s*[`'"]\s*(?:rm|sudo|chmod|chown)/gi,
    ruleId: "security/dangerous-command",
    severity: "error",
    message: "Potentially dangerous system command execution detected",
    suggestion: "Validate and sanitize all input before executing system commands.",
  },
];

// Quality issue patterns
const QUALITY_PATTERNS: Array<{
  pattern: RegExp;
  ruleId: string;
  severity: Severity;
  message: string;
  suggestion: string;
}> = [
  {
    pattern: /console\.log\s*\(/g,
    ruleId: "quality/no-console-log",
    severity: "info",
    message: "console.log() should not be in production code",
    suggestion: "Remove console.log() or use a proper logging library.",
  },
  {
    pattern: /debugger\s*;/g,
    ruleId: "quality/no-debugger",
    severity: "warning",
    message: "debugger statement found",
    suggestion: "Remove debugger statements before committing code.",
  },
  {
    pattern: /TODO|FIXME|HACK|XXX/g,
    ruleId: "quality/no-todo-comments",
    severity: "info",
    message: "TODO/FIXME comment found",
    suggestion: "Address the TODO or create a proper issue/ticket.",
  },
  {
    pattern: /catch\s*\(\s*\w*\s*\)\s*{\s*}/g,
    ruleId: "quality/no-empty-catch",
    severity: "warning",
    message: "Empty catch block swallows errors",
    suggestion: "Handle the error or at minimum log it for debugging.",
  },
  {
    pattern: /:\s*any\b/g,
    ruleId: "quality/no-explicit-any",
    severity: "warning",
    message: "Explicit 'any' type reduces type safety",
    suggestion: "Use a more specific type or 'unknown' if the type is truly unknown.",
  },
  {
    pattern: /\/\/\s*@ts-ignore/g,
    ruleId: "quality/no-ts-ignore",
    severity: "warning",
    message: "@ts-ignore suppresses TypeScript errors",
    suggestion: "Fix the underlying type issue instead of ignoring it.",
  },
];

function getLineAndColumn(code: string, index: number): { line: number; column: number } {
  const lines = code.substring(0, index).split("\n");
  return {
    line: lines.length,
    column: (lines[lines.length - 1]?.length ?? 0) + 1,
  };
}

function extractCodeSnippet(code: string, line: number, contextLines: number = 2): string {
  const lines = code.split("\n");
  const startLine = Math.max(0, line - contextLines - 1);
  const endLine = Math.min(lines.length, line + contextLines);
  
  return lines
    .slice(startLine, endLine)
    .map((l, i) => {
      const lineNum = startLine + i + 1;
      const marker = lineNum === line ? ">" : " ";
      return `${marker} ${lineNum.toString().padStart(4)} | ${l}`;
    })
    .join("\n");
}

function detectHallucinatedApis(code: string): AnalysisIssue[] {
  const issues: AnalysisIssue[] = [];

  for (const [api, info] of Object.entries(HALLUCINATED_APIS)) {
    // Create a pattern that matches the API call
    const parts = api.split(".");
    const methodName = parts[parts.length - 1];
    const pattern = new RegExp(`\\.${methodName}\\s*\\(`, "g");
    
    let match: RegExpExecArray | null;
    while ((match = pattern.exec(code)) !== null) {
      const { line, column } = getLineAndColumn(code, match.index);
      issues.push({
        type: "hallucinated-api",
        severity: "error",
        ruleId: `hallucination/${methodName}`,
        message: info.message,
        suggestion: `Use ${info.correct} instead.`,
        line,
        column,
        codeSnippet: extractCodeSnippet(code, line),
        confidence: 0.85,
      });
    }
  }

  return issues;
}

function detectDeprecatedMethods(code: string): AnalysisIssue[] {
  const issues: AnalysisIssue[] = [];

  for (const [method, info] of Object.entries(DEPRECATED_METHODS)) {
    const pattern = new RegExp(`\\b${method}\\b`, "g");
    
    let match: RegExpExecArray | null;
    while ((match = pattern.exec(code)) !== null) {
      const { line, column } = getLineAndColumn(code, match.index);
      issues.push({
        type: "deprecated-method",
        severity: "warning",
        ruleId: `deprecated/${method}`,
        message: `${method} is deprecated since ${info.since}`,
        suggestion: `Use ${info.replacement} instead.`,
        line,
        column,
        codeSnippet: extractCodeSnippet(code, line),
        confidence: 0.9,
      });
    }
  }

  return issues;
}

function detectSecurityIssues(code: string): AnalysisIssue[] {
  const issues: AnalysisIssue[] = [];

  for (const rule of SECURITY_PATTERNS) {
    let match: RegExpExecArray | null;
    // Reset lastIndex for global patterns
    rule.pattern.lastIndex = 0;
    
    while ((match = rule.pattern.exec(code)) !== null) {
      const { line, column } = getLineAndColumn(code, match.index);
      issues.push({
        type: "security-vulnerability",
        severity: rule.severity,
        ruleId: rule.ruleId,
        message: rule.message,
        suggestion: rule.suggestion,
        line,
        column,
        codeSnippet: extractCodeSnippet(code, line),
        confidence: 0.8,
      });
    }
  }

  return issues;
}

function detectQualityIssues(code: string): AnalysisIssue[] {
  const issues: AnalysisIssue[] = [];

  for (const rule of QUALITY_PATTERNS) {
    let match: RegExpExecArray | null;
    // Reset lastIndex for global patterns
    rule.pattern.lastIndex = 0;
    
    while ((match = rule.pattern.exec(code)) !== null) {
      const { line, column } = getLineAndColumn(code, match.index);
      issues.push({
        type: "quality-issue",
        severity: rule.severity,
        ruleId: rule.ruleId,
        message: rule.message,
        suggestion: rule.suggestion,
        line,
        column,
        codeSnippet: extractCodeSnippet(code, line),
        confidence: 0.75,
      });
    }
  }

  return issues;
}

function calculateTrustScore(issues: AnalysisIssue[]): { score: number; confidence: number } {
  let score = 100;
  let totalConfidence = 0;

  const severityWeights: Record<Severity, number> = {
    error: 15,
    warning: 5,
    info: 1,
  };

  for (const issue of issues) {
    const penalty = severityWeights[issue.severity] * issue.confidence;
    score -= penalty;
    totalConfidence += issue.confidence;
  }

  const avgConfidence = issues.length > 0 ? totalConfidence / issues.length : 1;

  return {
    score: Math.max(0, Math.min(100, Math.round(score))),
    confidence: avgConfidence,
  };
}

export async function analyzeCode(
  code: string,
  options: AnalysisOptions
): Promise<AnalysisResult> {
  const startTime = performance.now();

  const issues: AnalysisIssue[] = [];

  // Run all detections
  issues.push(...detectHallucinatedApis(code));
  issues.push(...detectDeprecatedMethods(code));
  issues.push(...detectSecurityIssues(code));
  issues.push(...detectQualityIssues(code));

  // Sort by severity and line number
  issues.sort((a, b) => {
    const severityOrder: Record<Severity, number> = { error: 0, warning: 1, info: 2 };
    const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
    if (severityDiff !== 0) return severityDiff;
    return a.line - b.line;
  });

  // Apply max issues limit if specified
  const limitedIssues = options.maxIssues 
    ? issues.slice(0, options.maxIssues) 
    : issues;

  const { score, confidence } = calculateTrustScore(limitedIssues);
  const linesOfCode = code.split("\n").length;
  const analysisTime = performance.now() - startTime;

  const errorCount = limitedIssues.filter((i) => i.severity === "error").length;
  const warningCount = limitedIssues.filter((i) => i.severity === "warning").length;
  const infoCount = limitedIssues.filter((i) => i.severity === "info").length;

  return {
    trustScore: score,
    confidence,
    issues: limitedIssues,
    linesOfCode,
    analysisTime,
    metadata: {
      language: options.language,
      framework: detectFramework(code),
      errorCount,
      warningCount,
      infoCount,
    },
  };
}

function detectFramework(code: string): string | undefined {
  // Check for Next.js first (it also uses React)
  if (code.includes("from 'next/") || code.includes('from "next/') || 
      code.includes("from 'next'") || code.includes('from "next"')) {
    return "Next.js";
  }
  if (code.includes("from 'react'") || code.includes('from "react"')) {
    return "React";
  }
  if (code.includes("from '@angular") || code.includes('from "@angular')) {
    return "Angular";
  }
  if (code.includes("from 'vue") || code.includes('from "vue')) {
    return "Vue";
  }
  if (code.includes("from 'express") || code.includes('from "express')) {
    return "Express";
  }
  return undefined;
}
